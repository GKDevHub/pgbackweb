# Frontend Development Guide

## 1. Project Structure

This document outlines the structure of the frontend-related files and folders within this project.

### `internal/view/static/`

This directory stores all static frontend assets. These assets are served directly or embedded into the Go binary.

*   **`css/`**: Contains compiled CSS files.
*   **`js/`**: Contains JavaScript files, often bundled or compiled.
*   **`images/`**: Stores images and other graphical assets.
*   **`libs/`**: Holds third-party frontend libraries.
*   **`build/app.min.js`**: This is the minified and bundled JavaScript application code, generated by a build process.
*   **`static_fs.go`**: This Go file is typically generated and used to embed the static assets located in this directory directly into the Go application binary. This allows the application to serve these assets without needing them to be present as separate files on the server.

### `internal/view/web/`

This directory contains the Go code responsible for generating HTML, handling frontend-related logic, and managing web routing.

*   **`auth/`**: Contains Go code related to user authentication views and logic (e.g., login, registration pages).
*   **`component/`**: Holds reusable UI components written in Go, often used to build up pages. These might be server-side rendered components.
*   **`dashboard/`**: Contains Go code for specific dashboard views and functionalities.
*   **`layout/`**: Defines the overall page layouts and templates used across the web application.

### `scripts/`

This directory contains various build and utility scripts to aid in development and deployment.

*   **`scripts/build-js.ts`**: This TypeScript script is responsible for bundling and processing JavaScript (and potentially TypeScript) files for the frontend. It likely uses Deno as its runtime.

### Root Files

These files, located at the root of the repository, are crucial for configuring and managing the frontend development environment.

*   **`deno.json`**: This file serves as the configuration for Deno, a JavaScript/TypeScript runtime. It can define tasks (similar to npm scripts), manage dependencies (including npm packages via `npm:` specifiers), and set up linter/formatter preferences for Deno-based scripts (like `scripts/build-js.ts`).
*   **`tailwind.config.ts`**: This TypeScript file configures Tailwind CSS. It specifies which files Tailwind should scan for class names (including `.go` files, indicating server-side template usage of Tailwind classes). It also likely includes the setup for DaisyUI, a Tailwind CSS component library.

## 2. Core Technologies

This section details the various technologies used in the frontend development process.

### 2.1. Go (Server-Side Rendering)
*   Go is utilized for backend application logic and for server-side rendering of HTML.
*   HTML content is primarily generated within Go functions, many of which are located in the `internal/view/web/` directory structure.
*   Tailwind CSS classes are typically embedded directly within the Go code that generates the HTML, allowing for styling at the point of generation.

### 2.2. Tailwind CSS & DaisyUI
*   Tailwind CSS serves as the primary utility-first CSS framework for styling the application's user interface.
*   The `tailwind.config.ts` file is central to Tailwind's configuration. It specifies project-specific customizations and, importantly, directs Tailwind to scan `.go` files within `internal/view/web/` to detect and include only the necessary CSS classes in the final stylesheet.
*   DaisyUI is integrated as a Tailwind CSS plugin, providing a collection of pre-styled components (like buttons, cards, menus) and themes, which accelerates UI development.
*   The final compiled CSS, incorporating Tailwind's utilities, DaisyUI components, and custom styles, is output to `internal/view/static/css/style.css`.

### 2.3. JavaScript (Alpine.js, HTMX)
*   **General JS:** Client-side JavaScript is employed to enhance user interactivity and provide dynamic frontend experiences that go beyond static HTML.
*   **`app.js`:** The file `internal/view/static/js/app.js` acts as the main entry point for global JavaScript. It's where core libraries are initialized and site-wide scripts are included.
*   **`*.inc.js` files:** Smaller, component-specific JavaScript snippets are often located in `*.inc.js` files. These files are typically co-located with their corresponding Go component templates within the `internal/view/web/` subdirectories. They are then gathered and bundled into the main `app.min.js` during the build process.
*   **Alpine.js:** This lightweight JavaScript framework is used to create interactive UI components directly within the HTML markup (which is generated by Go). It allows for declarative binding of behavior and state to HTML elements.
*   **HTMX:** HTMX plays a key role in enabling AJAX-powered partial page updates. It allows specific parts of a web page to be updated dynamically by fetching HTML fragments from the Go backend, without requiring a full page reload. This improves performance and user experience.

### 2.4. Deno
*   Deno, a modern and secure runtime for JavaScript and TypeScript, is used for frontend tooling and script execution within this project.
*   It is responsible for managing JavaScript dependencies, including npm packages (via `npm:` specifiers in `deno.json`), which are used by various frontend tools and scripts.
*   Deno is also used to run essential development scripts, such as the JavaScript build script (`scripts/build-js.ts`) and the script that triggers Tailwind CSS compilation.

### 2.5. esbuild
*   esbuild is an extremely fast JavaScript bundler and minifier, written in Go.
*   In this project, esbuild is utilized through the `scripts/build-js.ts` script (which is run by Deno). Its primary role is to bundle the main `internal/view/static/js/app.js` file along with all component-specific `*.inc.js` files into a single, minified JavaScript file: `internal/view/static/build/app.min.js`. This optimization reduces the number of HTTP requests and the overall size of JavaScript assets delivered to the client.

## 3. Build Process

This section details the various build processes involved in preparing frontend assets for the application.

### 3.1. JavaScript Bundling
*   The core of the JavaScript bundling process is managed by the `scripts/build-js.ts` script, which is executed using Deno (e.g., by running `deno run -A scripts/build-js.ts`).
*   The script performs the following steps:
    1.  It creates an initial prebuild from the main application JavaScript file: `internal/view/static/js/app.js`.
    2.  It then searches for all `*.inc.js` files (component-specific JavaScript snippets) located within the `internal/view/web/` directory structure. These found files are concatenated together to form another prebuild.
    3.  The main `app.js` prebuild and the concatenated `*.inc.js` prebuild are then merged into a single JavaScript file.
    4.  Finally, esbuild is invoked to bundle and minify this merged JavaScript content. The output is the production-ready file `internal/view/static/build/app.min.js`.

### 3.2. CSS Compilation
*   Styling is handled by Tailwind CSS, a utility-first framework. Its classes are applied directly within the Go code that generates the HTML content, typically within the `internal/view/web/` directories.
*   The `tailwind.config.ts` file is crucial for Tailwind's operation. It defines the project's specific theme, plugins (like DaisyUI), and, importantly, specifies the paths (including `.go` files) that Tailwind should scan to identify which CSS classes are being used.
*   The CSS compilation process generates a single stylesheet, `internal/view/static/css/style.css`, containing all necessary Tailwind utilities, DaisyUI component styles, and any custom CSS defined in the project.
*   This compilation is typically triggered using a Deno task runner, for example, by executing `deno task tailwindcss`. The specifics of this command are defined in the `deno.json` file.

### 3.3. Static Assets Embedding
*   The file `internal/view/static/static_fs.go` plays a key role in how static assets are handled in the deployed application.
*   This Go file is generally responsible for embedding all static assets – including the compiled CSS (`style.css`), bundled JavaScript (`app.min.js`), images, and any other files from `internal/view/static/` – directly into the Go application's binary executable.
*   The primary benefit of this approach is that it allows the entire application, including all its frontend assets, to be deployed as a single executable file. This simplifies deployment as there's no need for separate hosting or configuration for static files.

## 4. Development Workflow - Getting Started

This section outlines the steps to set up and run the frontend development environment.

### 4.1. Prerequisites
*   **Go:** Required for the backend application logic and server-side HTML generation.
*   **Deno:** Essential for JavaScript/TypeScript tooling, managing frontend dependencies (including npm packages via `deno.json`), and executing build scripts.
*   **Node.js (Optional):** While Deno aims to handle npm packages (e.g., via `deno.json`'s `nodeModulesDir: "auto"` setting), Node.js might still be needed if specific npm packages or globally installed Node-based tools cause issues. If you encounter problems with npm package resolution under Deno, consult Deno's official documentation.
*   **Git:** Required for version control and cloning the repository.

### 4.2. Initial Setup
1.  **Clone the repository:**
    ```bash
    git clone <repository-url>
    cd <repository-directory>
    ```
2.  **Environment Variables:**
    *   Check for any project-specific environment variable configurations (e.g., `.env.dev`, `.env.example`). While detailed backend setup is beyond this guide, some environment variables might influence frontend behavior or build processes. Refer to the main project `README.md` or backend documentation for specifics.
3.  **Install Dependencies:**
    *   Ensure Deno has cached necessary dependencies for scripts by running:
        ```bash
        deno cache --reload scripts/build-js.ts
        ```
    *   This command specifically reloads and caches dependencies for the JavaScript build script. If other Deno scripts have their own unique dependencies, you might need to run `deno cache --reload` for them as well, or look for a general initialization task in `deno.json` (e.g., `deno task init` if available).
    *   Tasks defined in `deno.json` might also be installed globally or locally using `deno install` if needed for easier execution.

### 4.3. Building Frontend Assets

#### JavaScript
*   **Command:**
    ```bash
    deno run -A scripts/build-js.ts
    ```
*   **Explanation:** This command executes the TypeScript script `build-js.ts` using Deno. The script bundles all JavaScript files (including `app.js` and `*.inc.js` files) and minifies the output into `internal/view/static/build/app.min.js`. The `-A` flag grants all permissions; ensure you trust the script.

#### CSS
*   **Command:** (Likely, based on typical `deno.json` task configurations)
    ```bash
    deno task tailwindcss
    ```
*   **Explanation:** This command executes the `tailwindcss` task defined in `deno.json`. It compiles your Tailwind CSS, scanning the configured files (including `.go` files) for class usage, and outputs the final stylesheet to `internal/view/static/css/style.css`.

#### Watch Mode (Development)
*   Running the build commands manually after every change can be inefficient during active development.
*   **Tailwind CSS:** Tailwind CSS CLI often includes a `--watch` flag. Check if the `tailwindcss` task in `deno.json` can be modified or if a separate watch task exists (e.g., `deno task tailwindcss:watch` or by running `deno task tailwindcss -- --watch` if the task forwards arguments).
*   **JavaScript/esbuild:** The current `scripts/build-js.ts` is a one-off build script. For automatic rebuilding of JavaScript on changes, you would typically need a separate watch script or tool that monitors your JS files and re-runs the `esbuild` process. This might involve tools like `denon` (for Deno scripts) or other file watchers that can trigger the build command.

### 4.4. Running the Application
*   This guide focuses on frontend development. For detailed instructions on compiling and running the main Go application, please refer to the project's root `README.md` or backend-specific documentation.
*   Typically, running the Go application might involve commands such as:
    ```bash
    go run cmd/app/main.go
    ```
    Or, if the project uses a task runner like Taskfile:
    ```bash
    task start 
    ```
    (Assuming a `start` task is defined in `taskfile.yaml` or a similar configuration file).

After building the frontend assets and running the Go application, you should be able to view the web application in your browser, typically at a local address like `http://localhost:8080` (the exact port may vary).

## 5. Adding New Features/Bug Fixes

This section describes the typical workflow for implementing frontend changes.

### 5.1. Making Changes to Go HTML (Server-Side)
*   HTML is primarily generated by Go functions. These functions are located within the `internal/view/web/` directory, often organized into subdirectories based on features or sections like `dashboard/`, `auth/`, or `component/`.
*   To modify a specific page or part of a page, you'll need to identify the corresponding Go file and function responsible for rendering that HTML. Navigation within the `internal/view/web/` structure and searching for unique text or CSS classes from the rendered page can help locate the correct file.
*   Tailwind CSS classes are applied directly within the Go code that generates the HTML. To change styling, you will add or modify these classes within the `.go` files.
*   After making any modifications to `.go` files, you must rebuild and restart the Go application to see the changes reflected in the browser. The method for rebuilding and restarting will depend on your specific Go development setup (e.g., `go run ...`, `task start`, or a live-reloading tool for Go).

### 5.2. Making Changes to JavaScript

*   **Global JavaScript:**
    *   For JavaScript logic that needs to be available across the entire application, or for defining new global utility functions, edit the main JavaScript file: `internal/view/static/js/app.js`.
*   **Component-Specific JavaScript:**
    *   If your JavaScript is tightly coupled to a particular UI component (especially Alpine.js components defined in Go HTML), it's best practice to place this code in a `*.inc.js` file. This file should be located in the same directory as the Go file that defines the component's HTML structure (e.g., within `internal/view/web/component/somecomponent/`).
*   **Re-building JS Assets:**
    *   After making any changes to JavaScript files (`app.js` or any `*.inc.js` files), you **must** run the JavaScript build script to bundle and minify your changes:
        ```bash
        deno run -A scripts/build-js.ts
        ```

### 5.3. Making Changes to CSS

*   **Tailwind CSS:**
    *   The vast majority of styling changes should be achieved by adding, removing, or modifying Tailwind CSS utility classes. These classes are applied directly in the Go files that generate the HTML markup.
    *   After you've updated the Tailwind classes in your Go files, you need to recompile the CSS so that Tailwind can process your changes and update the stylesheet:
        ```bash
        deno task tailwindcss
        ```
*   **Custom CSS:**
    *   If you encounter a styling requirement that cannot be met with Tailwind's utility classes or DaisyUI components, you can add custom CSS.
    *   Place custom CSS rules into one of the partial files located in `internal/view/static/css/partials/` (e.g., `general.css`).
    *   These partial files are imported into the main `internal/view/static/css/style.css` file, which is then processed by Tailwind. This ensures your custom styles are included and can even be augmented by Tailwind's processing (e.g., using Tailwind's `@apply` directive if needed, though this should be used sparingly).
    *   Remember to re-run the Tailwind compilation after adding or modifying custom CSS:
        ```bash
        deno task tailwindcss
        ```

### 5.4. Working with Components
*   Reusable UI components are primarily located in `internal/view/web/component/`.
*   Each component is typically a Go function that generates an HTML snippet. These components might also have an associated `*.inc.js` file in the same directory if they require specific client-side JavaScript for interactivity (often using Alpine.js).
*   **Using Existing Components:** To use an existing component, you simply call its Go function from another Go file that is generating HTML for a page or another component.
*   **Creating New Components:**
    1.  Create a new `.go` file for your component within `internal/view/web/component/` (or a relevant subdirectory).
    2.  Define a Go function in this file that returns the HTML for your component as a string or uses a template.
    3.  If the component requires client-side interactivity, create a corresponding `*.inc.js` file in the same directory.
    4.  Call your new component's Go function from the appropriate page or layout Go files where you want it to appear.
    5.  Remember to rebuild your Go application and frontend assets (JS and CSS) as needed.

### 5.5. Routing
*   Frontend routing (mapping URLs to the Go functions that generate page content) is handled server-side by Go.
*   The main web router for the application is typically defined in `internal/view/router.go`.
*   This main router often delegates routing for specific sections of the application to sub-routers. For example:
    *   Authentication-related routes (login, registration, etc.) are usually managed in `internal/view/web/auth/router.go`.
    *   Routes for the main application dashboard and its features are typically found in `internal/view/web/dashboard/router.go`. This dashboard router might further delegate to more specific routers within its subdirectories (e.g., `internal/view/web/dashboard/backups/router.go`, `internal/view/web/dashboard/databases/router.go`).
*   **Adding a New Page/Route:**
    1.  Identify the appropriate router file (main router or a sub-router) where your new route should be defined.
    2.  Define the new route, specifying the URL path and the HTTP method (e.g., GET, POST).
    3.  Create a new Go handler function. This function will be responsible for generating the HTML content for the new page. It will typically call various component functions and layout functions to build the final page.
    4.  Connect the route definition to your new handler function in the router file.
    5.  Rebuild and restart your Go application to activate the new route.
